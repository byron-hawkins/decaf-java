/*
 * Copyright (C) 2003 HawkinsSoftware
 *
 * This prototype of the Decaf Java development environment is free 
 * software.  You can redistribute it and/or modify it under the terms 
 * of the GNU General Public License as published by the Free Software 
 * Foundation.  However, no compilation of this code or a derivative
 * of it may be used with or integrated into any commercial application,
 * except by the written permisson of HawkinsSoftware.  Future versions 
 * of this product will be sold commercially under a different license.  
 * HawkinsSoftware retains all rights to this product, including its
 * concepts, design and implementation.
 *
 * This prototype is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
 
package com.bitwise.decaf.editor.grammar;

import java.io.*;
import java.util.*;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.border.*;

import org.hs.generator.*;
import org.hs.util.*;
import org.hs.jfc.*;

import com.bitwise.decaf.editor.*;

/**
 * CodeNode is the abstract base class for all nodes 
 * in the code tree under the {@link DMethod.BodyGrammar}.  
 * It maintains a reference to its
 * parent, and keeps a list of listeners to its content
 * changes.  All events fired by CodeNode and its 
 * subclasses are subsequently fired on the parent, and 
 * in this way recursively passed up the tree.  CodeNode 
 * fires events when:
 * <p>
 * 1) it receives a {@link ReferenceEvent}<br>
 * 2) it receives a call to the {@link GConstruct} reflection <br>
 * accessor set({@link java.lang.reflect.Field}, {@link java.lang.Object})
 * 3) it receives a call to {@link #notifyNewData()}
 * <p>
 * Use {@link #editPathToCup()} to open editors from the 
 * enclosing method body to this CodeNode; use 
 * {@link #describePathToCup()} to obtain a component 
 * displaying a String representation of this path.  
 */
public abstract class CodeNode extends GConstruct implements ScopeReference, ReferenceListener, Decaf
{
	static final long serialVersionUID = 8869556635651023096L;

	/**
	 * When the component that displays the complete content of 
	 * this CodeNode is in focus, this border is applied to 
	 * components that display a reference to this CodeNode. 
	 *
	 * @see Grammar.render()
	 */
	public static Border focusedBorder = BorderFactory.createLineBorder(Color.blue, 1);
	
	/**
	 * This border is applied to the single active selection item
	 * in a list of CodeNode`s.  Multiple selections may be highlighted
	 * with a background color (or any other way you like), but the single 
	 * most recent selection must be identified and marked with this border.
	 */
	public static Border selectedBorder = BorderFactory.createLineBorder(new Color(0x008800), 1);
	
	protected static int index = 0;
	
	protected int id;
	protected CodeNode parent;
	
	protected boolean perking;

	// we'll need to replace the vector listeners on serialization with a clone
	// that has no graphical creatures... how to define that? 

	protected Utils.SerialVector listeners;	// considered to be context dependent; cleared on relocate()

	protected transient Event outgoingEvent;
	
	CodeNode()
	{
		super("!!! This object was instantiated for internal reference purposes only !!!");
	}

	/**
	 * Abstract constructor with the identified <code>parent</code>.
	 */	
	public CodeNode(CodeNode parent)
	{
		super("[Generated by Decaf]");
		
		this.id = index++;
		this.parent = parent;
		
		this.listeners = new Utils.SerialVector();
		
		this.outgoingEvent = new Event(this);
		
		if (this.parent != null)
		{
			this.listeners.add(new PassItOn(this.parent));
		}
	}
	
	/**
	 * @return true if the content collection is empty or the content
	 * unit is null.
	 */
	public abstract boolean isEmpty();

	/**
	 * Notify this CodeNode that its data has changed.  A CodeNode.Event 
	 * of type DATA_CHANGED will be fired to the listeners.
	 */
	public void notifyNewData()
	{
		fireEvent(new Event(this, Event.DATA_CHANGED));
	}

	protected void applyMembers(Copy yourself)
	{
		((CodeNode)yourself).id = index++;
	}
	
	/**
	 * @return the parent of this CodeNode (null for a method body).
	 */
	public CodeNode getParent()
	{
		return this.parent;
	}
	
	/**
	 * Move this CodeNode in the code tree such that <code>parent</code>
	 * is its new parent.  
	 */
	public void setParent(CodeNode node)
	{
		this.parent = parent;

		this.listeners.add(new PassItOn(this.parent));	// remove the old one?
	}

	protected void fireEvent(Event event)
	{
		this.outgoingEvent = event;
		
		for (int i = 0; i < this.listeners.size(); i++)
		{
			((Listener)this.listeners.elementAt(i)).contentChanged(this.outgoingEvent);
		}
	}

	/**
	 * Internal facility
	 */	
	static class PassItOn implements Listener, Decaf
	{
		static final long serialVersionUID = -2267955525550189588L;

		CodeNode source;
		
		public PassItOn(CodeNode source)
		{
			this.source = source;
		}
		
		public void contentChanged(Event event)
		{
			// pass it up the line
			this.source.fireEvent(event);
		}
	}
	
	/**
	 * Fires a DATA_CHANGED event (without examining or relaying the
	 * content of <code>event</code>).
	 */
	public void referenceUpdated(ReferenceEvent event)
	{
		fireEvent(new Event(this, Event.DATA_CHANGED));
	}
	
	/**
	 * Fires a DATA_CHANGED event (without examining or relaying the
	 * content of <code>event</code>).
	 */
	public void referenceDeleted(ReferenceEvent event)
	{
		fireEvent(new Event(this, Event.DATA_CHANGED));
	}
	
	public void addListener(Listener listener)
	{
		this.listeners.add(listener);
	}
	
	public void removeListener(Listener listener)
	{
		this.listeners.remove(listener);
	}

	/**
	 * Fire a DATA_CHANGED event before passing this call on to super.
	 */	
	public void set(java.lang.reflect.Field field, Object value)
	{
		super.set(field, value);
		fireEvent(new Event(this, Event.DATA_CHANGED));
	}

	/**
	 * Open the editor for each CodeNode from the method body
	 * to <code>this</code>.
	 */ 	
	public void editPathToCup()
	{
		CodeNode node = this;
		
		Stack trace = new Stack();
		
		while (node != null)
		{
			trace.push(node);
			node = node.getParent();
		}
		
		// need to open the method editor
		DMethod.BodyGrammar methodBody = (DMethod.BodyGrammar)trace.pop();
		MethodEditor methodEditor = methodBody.editMethod(); 
		methodEditor.setLocation(0,0);

		MaskEditor editor = null; 
		JDialog previousEditor = methodEditor;
		int x = 0, y = 0;

		Grammar nextToEdit;		
		while (true)
		{
			node = (CodeNode)trace.pop();
			
			if (node instanceof Grammar)
			{
				nextToEdit = (Grammar)node;
			}
			else
			{
				continue;
			}

			previousEditor = editor;
			editor = nextToEdit.edit();
			if (editor != null)
			{
				editor.setLocation(x += 10, y += 10);
				editor.setLocationRelativeTo(previousEditor);
			}

			if (node == this)
			{
				break;
			}
		}
	}

	public DMethod getEnclosingMethod()
	{
		return this.parent.getEnclosingMethod();
	}

	/**
	 * @return a JComponent containing a text description of the 
	 * code tree route from the method body to <code>this</code>
	 */	
	public JComponent describePathToCup()
	{
		CodeNode node = this;
		
		PathDescription description = new PathDescription();
		
		while (node != null)
		{
			if (node instanceof Grammar)
			{
				description.step((Grammar)node);
			}
			node = node.getParent();
		}
		
		// how do I get the method on here?
		
		return description;
	}

	/**
	 * @return a Phrase containing a reference to the keyword <code>this</code>,
	 * constructed in the context of this CodeNode.
	 */	
	public Phrase createThisReference()
	{
		Phrase thisPrefix = new Phrase(this);
		thisPrefix.content = DVariable.getThis(identifyCup());
		return thisPrefix;
	}

	/**
	 * @return true if <code>o</code> is a CodeNode and has the same 
	 * <code>id</code> as <code>this</code>
	 */	
	public boolean equals(Object o)
	{
		if (o instanceof CodeNode)
		{
			return (this.id == ((CodeNode)o).id);
		}
		return false;
	}

	/**
	 * Internal stuff.
	 */	
	public Object readResolve()
		throws java.io.ObjectStreamException 
	{
		this.outgoingEvent = new Event(this);
		return this;
	}

	/**
	 * Radio frequency for CodeNode communications.
	 */	
	public static interface Listener 
	{
		public void contentChanged(Event event);
	}
	
	/**
	 * The component returned by <code>describePathToCup()</code>.
	 */
	static class PathDescription extends Utils.RenderPanel
	{
		protected boolean firstEntry = true;
		
		public void step(Grammar grammar)
		{
			if (!this.firstEntry)
			{
				super.add(new Utils.RenderLabel(" => "), 0);
			}
			this.firstEntry = false;
			super.add(grammar.render(), 0);
		}
	}

	/**
	 * The class of event object fired by this class.  
	 */	
	public static class Event extends java.util.EventObject
	{
		/**
		 * Event type, indicating that the data of the corresponding
		 * CodeNode has changed in some way.  May be combined with
		 * other types.
		 */
		public static final int DATA_CHANGED = 1;	
		
		/**
		 * Event type, indicating that the state of the corresponding
		 * CodeNode (e.g., Grammar.blue) has changed in some way.  May 
		 * be combined with other types.
		 */
		public static final int STATE_CHANGED = 2;	// focus and blue
		
		protected int activity;

		public Event(CodeNode source)
		{
			this(source, 0);
		}
		
		public Event(CodeNode source, int activity)
		{
			super(source);
			
			this.activity = activity;
		}
		
		/**
		 * Include DATA_CHANGED in this event's type.
		 */
		public void applyDataChange()
		{
			this.activity |= DATA_CHANGED;
		}
		
		/**
		 * Include STATE_CHANGED in this event's type.
		 */
		public void applyStateChange()
		{
			this.activity |= STATE_CHANGED;
		}
		
		/**
		 * @return true if this event indicates a data change 
		 * (i.e., type includes DATA_CHANGED)
		 */
		public boolean dataChanged()
		{
			return ((this.activity & DATA_CHANGED) > 0);
		}
		
		/**
		 * @return true if this event indicates a state change 
		 * (i.e., type includes STATE_CHANGED)
		 */
		public boolean stateChanged()
		{
			return ((this.activity & STATE_CHANGED) > 0);
		}
	}
}

