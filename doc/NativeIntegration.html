

<html>
<head>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>

<h2>Decaf Native Integration</h2>

Those familiar with Java will know that its facilities for integrating with so-called
"native" (platform dependent) applications are no Smorgasboard of functional convenience.
This is one of the primary reasons for <u>not</u> using Java, along with memory overhead 
and language restrictiveness (both of which are beyond my control, though the latter actually
proves beneficial for Decaf).  In exploring the options for a standard integration module, 
by which the process could be simplified and made reliable, I discovered that there are
in fact a wealth of possibilities for attaching Java to native code.  They simply require
a lot of planning, and usually are laborious to code.  Therefore, instead of narrowing
the field to a specific implementation for all Decaf users, I've implemented the module
<a href="api/c++/index.html#plugin">plugin.o</a> as an example of one concise and convenient bridge to Java.  
The tasks required to use it are described in detail in this document, and the <a href="api/c++/index.html">
source code</a> for uMail has been provided.
<p><a name="IntrinsicAccessibility"/>
<h3>Intrinsic Accessibility</h3>
This present implementation of plugin.o is particularly organized for 
the principle of <a href="Glossary.html#IntrinsicAccessibility">intrinsic accessibility</a>.  
This principle states that the optimal
means of allowing users to customize an application is to provide them with access to
the source code itself, at reasonable granularity.  uMail demonstrates the principle by implementing part or all of each of its 
system operations as a plugin, using its base class <a href="api/c++/uMail.html#Activity">Activity</a>
to establish a plugin method name and signature for each system object.  The Activity class
keeps a reference to a <a href="api/c++/plugin.html#Plugin">Plugin</a>, defined generically in 
plugin.o, which facilitates the instantiation and execution of plugin methods.  The standard uMail behavior
is then implemented by the default plugin uMailPlugins.cup, which users are allowed to modify at their convenience.  
<p>
<h3>Dynamic Library</h3>
Once plugins are integrated into the system, the next task is to implement a callback 
mechanism by which the plugin interacts with system objects in the main application.  
The <a href="Glossary.html#JNI">JNI</a> will only allow Java to call methods exported 
from a dynamic library, which limits the options available for application assembly.
<dir>
<li>Deliver the application entirely as a dynamic library
<li>Provide a separate library that is able to communicate with the main application.  
</dir>
The demo application uMail currently demonstrates the latter case, though its separate dynamic
library <a href="api/c++/index.html#jMail">jMail.dll</a> is attached to the main application 
by simply linking with its object files.  A more realistic approach to this second option
is to pass a block of function pointers representing methods of the main application to the 
dynamic library on initialization.  Here is an <a href="api/c++/jMail.html#function_pointer">example</a> 
of what this looks like.  
<p>
<h3>SWIG</h3>
The process of exporting main application methods for plugin use can be greatly simplified 
by using the code generator <a href="lib/swig/Manual/index.html">SWIG</a>.  The 
format of the input file to SWIG is only a slight modification of a C++ header file -- in
fact, it can be only 4 lines long and forward its entire content to the actual header(s) 
of the module(s) you wish to export.  For each class represented in its input file, SWIG 
generates a Java class with the same name and providing exactly the same methods; data type
conversion is specified in the <a href="lib/swig/Manual/Java.html#n47">typemap</a>
section of the SWIG manual.  SWIG completes the connection from the Java classes to the
classes of the main application by generating a file of C functions, properly declared for
Java to import them, and each routing the body of a Java method to the body of the 
corresponding C++ method.  Simply include this file in the dynamic library, and all the 
methods required for Java to communicate with the main application will be correctly
exported from it.  Be sure to use a name mangling scheme that is recognizable to Java.
The Java classes generated by SWIG are extensively 
customizable; see uMail's SWIG input file <a href="api/c++/uMail_i.html">uMail.i</a> for
a few examples.
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
</body>